from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import GameState, ArticleCache, UserGuess, DailyArticle
from .serializers import GameStateSerializer
from .text_utils import generate_scrambled_text, calculate_guess_score
import random
from django.utils import timezone


class GameStateView(APIView):
    """Create or retrieve game states"""

    def get(self, request, format=None):
        """Get a user's current game state(s)"""
        game_id = request.query_params.get('game_id', None)

        if game_id:
            # Get a specific game state
            try:
                game_state = GameState.objects.get(id=game_id, user=request.user)
                serializer = GameStateSerializer(game_state)
                return Response(serializer.data)
            except GameState.DoesNotExist:
                return Response({"error": "Game state not found"}, status=status.HTTP_404_NOT_FOUND)
        else:
            # Get all game states for the user
            game_states = GameState.objects.filter(user=request.user).order_by('-created_at')
            serializer = GameStateSerializer(game_states, many=True)
            return Response(serializer.data)

    def post(self, request, format=None):
        """Create a new game state"""
        article_id = request.data.get('article_id', None)

        if not article_id:
            return Response({"error": "Article ID is required"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            article = ArticleCache.objects.get(id=article_id)

            # Create scrambled text dictionary (generated by NLP processing module)
            word_mapping = generate_scrambled_text(article.content)

            # Create new game state
            game_state = GameState.objects.create(
                user=request.user,
                article=article,
                word_mapping=word_mapping
            )

            serializer = GameStateSerializer(game_state)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ArticleCache.DoesNotExist:
            return Response({"error": "Article not found"}, status=status.HTTP_404_NOT_FOUND)


class UserGuessView(APIView):
    """Submit guesses and get scores"""

    def post(self, request, format=None):
        """Submit a new guess"""
        game_id = request.data.get('game_id', None)
        guess_text = request.data.get('guess', None)

        if not game_id or not guess_text:
            return Response({"error": "Game ID and guess text are required"},
                            status=status.HTTP_400_BAD_REQUEST)

        try:
            game_state = GameState.objects.get(id=game_id, user=request.user)

            # If game is completed or max guesses reached, don't allow further guesses
            if game_state.is_completed:
                return Response({"error": "Game is already completed"},
                                status=status.HTTP_400_BAD_REQUEST)

            current_guesses_count = UserGuess.objects.filter(game_state=game_state).count()
            if current_guesses_count >= game_state.max_guesses:
                return Response({"error": "Maximum guess attempts reached"},
                                status=status.HTTP_400_BAD_REQUEST)

            # Calculate score and similarity (computed by NLP processing module)
            article_title = game_state.article.title
            score, similarity = calculate_guess_score(guess_text, article_title)

            # Create new guess record
            user_guess = UserGuess.objects.create(
                game_state=game_state,
                guess_text=guess_text,
                score=score,
                similarity_score=similarity
            )

            # If correct guess, update game state to completed
            if similarity >= 0.9:  # Assume similarity over 90% is correct
                game_state.is_completed = True
                game_state.best_score = max(game_state.best_score, score)
                game_state.save()

            # Return guess results
            result = {
                "guess": guess_text,
                "score": score,
                "similarity": similarity,
                "attempt": current_guesses_count + 1,
                "max_attempts": game_state.max_guesses,
                "is_completed": game_state.is_completed
            }

            return Response(result, status=status.HTTP_201_CREATED)

        except GameState.DoesNotExist:
            return Response({"error": "Game state not found"},
                            status=status.HTTP_404_NOT_FOUND)


class ScrambledDictionaryView(APIView):
    """Get the scrambled word dictionary for an article"""

    def get(self, request, format=None):
        """Get the scrambled dictionary for a specific game state"""
        game_id = request.query_params.get('game_id', None)

        if not game_id:
            return Response({"error": "Game ID is required"},
                            status=status.HTTP_400_BAD_REQUEST)

        try:
            game_state = GameState.objects.get(id=game_id, user=request.user)
            return Response({"word_mapping": game_state.word_mapping})

        except GameState.DoesNotExist:
            return Response({"error": "Game state not found"},
                            status=status.HTTP_404_NOT_FOUND)


class SetArticleView(APIView):
    """Set the article for a game"""

    def post(self, request, format=None):
        """Set article by ID or source"""
        article_id = request.data.get('article_id', None)
        source = request.data.get('source', None)

        if not (article_id or source):
            return Response({"error": "Article ID or source is required"},
                            status=status.HTTP_400_BAD_REQUEST)

        try:
            # Get article by ID
            if article_id:
                article = ArticleCache.objects.get(id=article_id)

            # Get daily article by source
            elif source == 'daily':
                today = timezone.now().date()
                daily_article = DailyArticle.objects.get(date=today)
                article = daily_article.article

            # Get random article
            elif source == 'random':
                # Get a random article
                count = ArticleCache.objects.count()
                if count == 0:
                    return Response({"error": "No articles available"},
                                    status=status.HTTP_404_NOT_FOUND)

                random_index = random.randint(0, count - 1)
                article = ArticleCache.objects.all()[random_index]

            else:
                return Response({"error": "Invalid source"},
                                status=status.HTTP_400_BAD_REQUEST)

            # Return article info
            return Response({
                "article_id": article.id,
                "title": article.title,
                "retrieved_date": article.retrieved_date
            })

        except (ArticleCache.DoesNotExist, DailyArticle.DoesNotExist):
            return Response({"error": "Article not found"},
                            status=status.HTTP_404_NOT_FOUND)
